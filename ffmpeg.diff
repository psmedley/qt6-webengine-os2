diff --git a/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc b/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
index 9b1ad9f7675..c8343bbb16a 100644
--- a/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
+++ b/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
@@ -74,7 +74,7 @@ void CdmAudioDecoderConfigToAVCodecContext(
       codec_context->sample_fmt = AV_SAMPLE_FMT_NONE;
   }
 
-  codec_context->ch_layout.nb_channels = config.channel_count;
+  codec_context->channels = config.channel_count;
   codec_context->sample_rate = config.samples_per_second;
 
   if (config.extra_data) {
@@ -124,8 +124,8 @@ void CopySamples(cdm::AudioFormat cdm_format,
     case cdm::kAudioFormatPlanarS16:
     case cdm::kAudioFormatPlanarF32: {
       const int decoded_size_per_channel =
-          decoded_audio_size / av_frame.ch_layout.nb_channels;
-      for (int i = 0; i < av_frame.ch_layout.nb_channels; ++i) {
+          decoded_audio_size / av_frame.channels;
+      for (int i = 0; i < av_frame.channels; ++i) {
         memcpy(output_buffer, av_frame.extended_data[i],
                decoded_size_per_channel);
         output_buffer += decoded_size_per_channel;
@@ -185,14 +185,13 @@ bool FFmpegCdmAudioDecoder::Initialize(
   // Success!
   decoding_loop_ = std::make_unique<FFmpegDecodingLoop>(codec_context_.get());
   samples_per_second_ = config.samples_per_second;
-  bytes_per_frame_ =
-      codec_context_->ch_layout.nb_channels * config.bits_per_channel / 8;
+  bytes_per_frame_ = codec_context_->channels * config.bits_per_channel / 8;
   output_timestamp_helper_ =
       std::make_unique<AudioTimestampHelper>(config.samples_per_second);
   is_initialized_ = true;
 
   // Store initial values to guard against midstream configuration changes.
-  channels_ = codec_context_->ch_layout.nb_channels;
+  channels_ = codec_context_->channels;
   av_sample_format_ = codec_context_->sample_fmt;
 
   return true;
@@ -292,9 +291,8 @@ cdm::Status FFmpegCdmAudioDecoder::DecodeBuffer(
   for (auto& frame : audio_frames) {
     int decoded_audio_size = 0;
     if (frame->sample_rate != samples_per_second_ ||
-        frame->ch_layout.nb_channels != channels_ ||
-        frame->format != av_sample_format_) {
-      DLOG(ERROR) << "Unsupported midstream configuration change!"
+    frame->channels != channels_ || frame->format != av_sample_format_) {
+        DLOG(ERROR) << "Unsupported midstream configuration change!"
                   << " Sample Rate: " << frame->sample_rate << " vs "
                   << samples_per_second_
                   << ", Channels: " << frame->ch_layout.nb_channels << " vs "
@@ -304,7 +302,7 @@ cdm::Status FFmpegCdmAudioDecoder::DecodeBuffer(
     }
 
     decoded_audio_size = av_samples_get_buffer_size(
-        nullptr, codec_context_->ch_layout.nb_channels, frame->nb_samples,
+        nullptr, codec_context_->channels, frame->nb_samples,
         codec_context_->sample_fmt, 1);
     if (!decoded_audio_size)
       continue;
@@ -324,7 +322,7 @@ bool FFmpegCdmAudioDecoder::OnNewFrame(
     std::vector<std::unique_ptr<AVFrame, ScopedPtrAVFreeFrame>>* audio_frames,
     AVFrame* frame) {
   *total_size += av_samples_get_buffer_size(
-      nullptr, codec_context_->ch_layout.nb_channels, frame->nb_samples,
+      nullptr, codec_context_->channels, frame->nb_samples,
       codec_context_->sample_fmt, 1);
   audio_frames->emplace_back(av_frame_clone(frame));
   return true;
diff --git a/chromium/media/ffmpeg/ffmpeg_common.cc b/chromium/media/ffmpeg/ffmpeg_common.cc
index 76f03d6608e..87ca8969626 100644
--- a/chromium/media/ffmpeg/ffmpeg_common.cc
+++ b/chromium/media/ffmpeg/ffmpeg_common.cc
@@ -345,11 +345,10 @@ bool AVCodecContextToAudioDecoderConfig(const AVCodecContext* codec_context,
       codec_context->sample_fmt, codec_context->codec_id);
 
   ChannelLayout channel_layout =
-      codec_context->ch_layout.nb_channels > 8
+      codec_context->channels > 8
           ? CHANNEL_LAYOUT_DISCRETE
-          : ChannelLayoutToChromeChannelLayout(
-                codec_context->ch_layout.u.mask,
-                codec_context->ch_layout.nb_channels);
+          : ChannelLayoutToChromeChannelLayout(codec_context->channel_layout,
+                                               codec_context->channels);
 
   int sample_rate = codec_context->sample_rate;
   switch (codec) {
@@ -402,7 +401,7 @@ bool AVCodecContextToAudioDecoderConfig(const AVCodecContext* codec_context,
                      extra_data, encryption_scheme, seek_preroll,
                      codec_context->delay);
   if (channel_layout == CHANNEL_LAYOUT_DISCRETE)
-    config->SetChannelsForDiscrete(codec_context->ch_layout.nb_channels);
+    config->SetChannelsForDiscrete(codec_context->channels);
 
 #if BUILDFLAG(ENABLE_PLATFORM_AC3_EAC3_AUDIO)
   // These are bitstream formats unknown to ffmpeg, so they don't have
@@ -471,7 +470,7 @@ void AudioDecoderConfigToAVCodecContext(const AudioDecoderConfig& config,
 
   // TODO(scherkus): should we set |channel_layout|? I'm not sure if FFmpeg uses
   // said information to decode.
-  codec_context->ch_layout.nb_channels = config.channels();
+  codec_context->channels = config.channels();
   codec_context->sample_rate = config.samples_per_second();
 
   if (config.extra_data().empty()) {
diff --git a/chromium/media/filters/audio_file_reader.cc b/chromium/media/filters/audio_file_reader.cc
index e1be5aa9a5b..5f257bdfaa6 100644
--- a/chromium/media/filters/audio_file_reader.cc
+++ b/chromium/media/filters/audio_file_reader.cc
@@ -113,15 +113,14 @@ bool AudioFileReader::OpenDecoder() {
 
   // Verify the channel layout is supported by Chrome.  Acts as a sanity check
   // against invalid files.  See http://crbug.com/171962
-  if (ChannelLayoutToChromeChannelLayout(
-          codec_context_->ch_layout.u.mask,
-          codec_context_->ch_layout.nb_channels) ==
+  if (ChannelLayoutToChromeChannelLayout(codec_context_->channel_layout,
+                                         codec_context_->channels) ==
       CHANNEL_LAYOUT_UNSUPPORTED) {
     return false;
   }
 
   // Store initial values to guard against midstream configuration changes.
-  channels_ = codec_context_->ch_layout.nb_channels;
+  channels_ = codec_context_->channels;
   audio_codec_ = CodecIDToAudioCodec(codec_context_->codec_id);
   sample_rate_ = codec_context_->sample_rate;
   av_sample_format_ = codec_context_->sample_fmt;
@@ -224,7 +223,7 @@ bool AudioFileReader::OnNewFrame(
   if (frames_read < 0)
     return false;
 
-  const int channels = frame->ch_layout.nb_channels;
+  const int channels = frame->channels;
   if (frame->sample_rate != sample_rate_ || channels != channels_ ||
       frame->format != av_sample_format_) {
     DLOG(ERROR) << "Unsupported midstream configuration change!"
diff --git a/chromium/media/filters/ffmpeg_aac_bitstream_converter.cc b/chromium/media/filters/ffmpeg_aac_bitstream_converter.cc
index ca5e5fb927d..6f231c85729 100644
--- a/chromium/media/filters/ffmpeg_aac_bitstream_converter.cc
+++ b/chromium/media/filters/ffmpeg_aac_bitstream_converter.cc
@@ -195,15 +195,14 @@ bool FFmpegAACBitstreamConverter::ConvertPacket(AVPacket* packet) {
   if (!header_generated_ || codec_ != stream_codec_parameters_->codec_id ||
       audio_profile_ != stream_codec_parameters_->profile ||
       sample_rate_index_ != sample_rate_index ||
-      channel_configuration_ !=
-          stream_codec_parameters_->ch_layout.nb_channels ||
+      channel_configuration_ != stream_codec_parameters_->channels ||
       frame_length_ != header_plus_packet_size) {
     header_generated_ =
         GenerateAdtsHeader(stream_codec_parameters_->codec_id,
                            0,  // layer
                            stream_codec_parameters_->profile, sample_rate_index,
                            0,  // private stream
-                           stream_codec_parameters_->ch_layout.nb_channels,
+                           stream_codec_parameters_->channels,
                            0,  // originality
                            0,  // home
                            0,  // copyrighted_stream
@@ -215,7 +214,7 @@ bool FFmpegAACBitstreamConverter::ConvertPacket(AVPacket* packet) {
     codec_ = stream_codec_parameters_->codec_id;
     audio_profile_ = stream_codec_parameters_->profile;
     sample_rate_index_ = sample_rate_index;
-    channel_configuration_ = stream_codec_parameters_->ch_layout.nb_channels;
+    channel_configuration_ = stream_codec_parameters_->channels;
     frame_length_ = header_plus_packet_size;
   }
 
diff --git a/chromium/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc b/chromium/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc
index f59bcd8fdaf..1fd4c5ccd7d 100644
--- a/chromium/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc
+++ b/chromium/media/filters/ffmpeg_aac_bitstream_converter_unittest.cc
@@ -34,7 +34,7 @@ class FFmpegAACBitstreamConverterTest : public testing::Test {
     memset(&test_parameters_, 0, sizeof(AVCodecParameters));
     test_parameters_.codec_id = AV_CODEC_ID_AAC;
     test_parameters_.profile = FF_PROFILE_AAC_MAIN;
-    test_parameters_.ch_layout.nb_channels = 2;
+    test_parameters_.channels = 2;
     test_parameters_.extradata = extradata_header_;
     test_parameters_.extradata_size = sizeof(extradata_header_);
   }
diff --git a/chromium/media/filters/ffmpeg_audio_decoder.cc b/chromium/media/filters/ffmpeg_audio_decoder.cc
index 4615fdeb3fb..6a56c675f7d 100644
--- a/chromium/media/filters/ffmpeg_audio_decoder.cc
+++ b/chromium/media/filters/ffmpeg_audio_decoder.cc
@@ -28,7 +28,7 @@ namespace media {
 
 // Return the number of channels from the data in |frame|.
 static inline int DetermineChannels(AVFrame* frame) {
-  return frame->ch_layout.nb_channels;
+  return frame->channels;
 }
 
 // Called by FFmpeg's allocation routine to allocate a buffer. Uses
@@ -231,7 +231,7 @@ bool FFmpegAudioDecoder::OnNewFrame(const DecoderBuffer& buffer,
   // Translate unsupported into discrete layouts for discrete configurations;
   // ffmpeg does not have a labeled discrete configuration internally.
   ChannelLayout channel_layout = ChannelLayoutToChromeChannelLayout(
-      codec_context_->ch_layout.u.mask, codec_context_->ch_layout.nb_channels);
+      codec_context_->channel_layout, codec_context_->channels);
   if (channel_layout == CHANNEL_LAYOUT_UNSUPPORTED &&
       config_.channel_layout() == CHANNEL_LAYOUT_DISCRETE) {
     channel_layout = CHANNEL_LAYOUT_DISCRETE;
@@ -348,11 +348,11 @@ bool FFmpegAudioDecoder::ConfigureDecoder(const AudioDecoderConfig& config) {
   // Success!
   av_sample_format_ = codec_context_->sample_fmt;
 
-  if (codec_context_->ch_layout.nb_channels != config.channels()) {
+  if (codec_context_->channels != config.channels()) {
     MEDIA_LOG(ERROR, media_log_)
         << "Audio configuration specified " << config.channels()
         << " channels, but FFmpeg thinks the file contains "
-        << codec_context_->ch_layout.nb_channels << " channels";
+        << codec_context_->channels << " channels";
     ReleaseFFmpegResources();
     state_ = DecoderState::kUninitialized;
     return false;
@@ -403,7 +403,7 @@ int FFmpegAudioDecoder::GetAudioBuffer(struct AVCodecContext* s,
   if (frame->nb_samples <= 0)
     return AVERROR(EINVAL);
 
-  if (s->ch_layout.nb_channels != channels) {
+  if (s->channels != channels) {
     DLOG(ERROR) << "AVCodecContext and AVFrame disagree on channel count.";
     return AVERROR(EINVAL);
   }
@@ -436,8 +436,7 @@ int FFmpegAudioDecoder::GetAudioBuffer(struct AVCodecContext* s,
   ChannelLayout channel_layout =
       config_.channel_layout() == CHANNEL_LAYOUT_DISCRETE
           ? CHANNEL_LAYOUT_DISCRETE
-          : ChannelLayoutToChromeChannelLayout(s->ch_layout.u.mask,
-                                               s->ch_layout.nb_channels);
+          : ChannelLayoutToChromeChannelLayout(s->channel_layout, s->channels);
 
   if (channel_layout == CHANNEL_LAYOUT_UNSUPPORTED) {
     DLOG(ERROR) << "Unsupported channel layout.";
diff --git a/chromium/media/filters/ffmpeg_demuxer.cc b/chromium/media/filters/ffmpeg_demuxer.cc
index bfc6dacf1fe..1a478f713fe 100644
--- a/chromium/media/filters/ffmpeg_demuxer.cc
+++ b/chromium/media/filters/ffmpeg_demuxer.cc
@@ -58,7 +58,7 @@ namespace media {
 
 namespace {
 
-constexpr int64_t kInvalidPTSMarker = static_cast<int64_t>(0x8000000000000000);
+constexpr int64_t kRelativeTsBase = static_cast<int64_t>(0x7ffeffffffffffff);
 
 void SetAVStreamDiscard(AVStream* stream, AVDiscard discard) {
   DCHECK(stream);
@@ -101,7 +101,7 @@ static base::TimeDelta FramesToTimeDelta(int frames, double sample_rate) {
                             sample_rate);
 }
 
-static base::TimeDelta ExtractStartTime(AVStream* stream) {
+static base::TimeDelta ExtractStartTime(AVStream* stream, int64_t first_dts) {
   // The default start time is zero.
   base::TimeDelta start_time;
 
@@ -111,12 +111,12 @@ static base::TimeDelta ExtractStartTime(AVStream* stream) {
 
   // Next try to use the first DTS value, for codecs where we know PTS == DTS
   // (excludes all H26x codecs). The start time must be returned in PTS.
-  if (av_stream_get_first_dts(stream) != kNoFFmpegTimestamp &&
+  if (first_dts != AV_NOPTS_VALUE &&
       stream->codecpar->codec_id != AV_CODEC_ID_HEVC &&
       stream->codecpar->codec_id != AV_CODEC_ID_H264 &&
       stream->codecpar->codec_id != AV_CODEC_ID_MPEG4) {
     const base::TimeDelta first_pts =
-        ConvertFromTimeBase(stream->time_base, av_stream_get_first_dts(stream));
+        ConvertFromTimeBase(stream->time_base, first_dts);
     if (first_pts < start_time)
       start_time = first_pts;
   }
@@ -285,6 +285,7 @@ FFmpegDemuxerStream::FFmpegDemuxerStream(
       fixup_negative_timestamps_(false),
       fixup_chained_ogg_(false),
       num_discarded_packet_warnings_(0),
+      first_dts_(AV_NOPTS_VALUE),
       last_packet_pos_(AV_NOPTS_VALUE),
       last_packet_dts_(AV_NOPTS_VALUE) {
   DCHECK(demuxer_);
@@ -351,6 +352,11 @@ void FFmpegDemuxerStream::EnqueuePacket(ScopedAVPacket packet) {
   int64_t packet_dts =
       packet->dts == AV_NOPTS_VALUE ? packet->pts : packet->dts;
 
+  if (first_dts_ == AV_NOPTS_VALUE && packet->dts != AV_NOPTS_VALUE &&
+      last_packet_dts_ != AV_NOPTS_VALUE) {
+    first_dts_ = packet->dts - (last_packet_dts_ + kRelativeTsBase);
+  }
+
   // Chained ogg files have non-monotonically increasing position and time stamp
   // values, which prevents us from using them to determine if a packet should
   // be dropped. Since chained ogg is only allowed on single track audio only
@@ -1449,7 +1455,7 @@ void FFmpegDemuxer::OnFindStreamInfoDone(int result) {
 
     max_duration = std::max(max_duration, streams_[i]->duration());
 
-    base::TimeDelta start_time = ExtractStartTime(stream);
+    base::TimeDelta start_time = ExtractStartTime(stream, streams_[i]->first_dts());
 
     // Note: This value is used for seeking, so we must take the true value and
     // not the one possibly clamped to zero below.
@@ -1606,7 +1612,7 @@ FFmpegDemuxerStream* FFmpegDemuxer::FindStreamWithLowestStartTimestamp(
   for (const auto& stream : streams_) {
     if (!stream || stream->IsEnabled() != enabled)
       continue;
-    if (av_stream_get_first_dts(stream->av_stream()) == kInvalidPTSMarker)
+    if (stream->first_dts() == AV_NOPTS_VALUE)
       continue;
     if (!lowest_start_time_stream ||
         stream->start_time() < lowest_start_time_stream->start_time()) {
@@ -1627,7 +1633,7 @@ FFmpegDemuxerStream* FFmpegDemuxer::FindPreferredStreamForSeeking(
     if (stream->type() != DemuxerStream::VIDEO)
       continue;
 
-    if (av_stream_get_first_dts(stream->av_stream()) == kInvalidPTSMarker)
+    if (stream->first_dts() == AV_NOPTS_VALUE)
       continue;
 
     if (!stream->IsEnabled())
diff --git a/chromium/media/filters/ffmpeg_demuxer.h b/chromium/media/filters/ffmpeg_demuxer.h
index 45ab0f348ad..6b093318f36 100644
--- a/chromium/media/filters/ffmpeg_demuxer.h
+++ b/chromium/media/filters/ffmpeg_demuxer.h
@@ -152,6 +152,8 @@ class MEDIA_EXPORT FFmpegDemuxerStream : public DemuxerStream {
   base::TimeDelta start_time() const { return start_time_; }
   void set_start_time(base::TimeDelta time) { start_time_ = time; }
 
+  int64_t first_dts() const { return first_dts_; }
+
  private:
   friend class FFmpegDemuxerTest;
 
@@ -209,6 +211,7 @@ class MEDIA_EXPORT FFmpegDemuxerStream : public DemuxerStream {
   bool fixup_chained_ogg_;
 
   int num_discarded_packet_warnings_;
+  int64_t first_dts_;
   int64_t last_packet_pos_;
   int64_t last_packet_dts_;
 };
